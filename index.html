<!doctype html>
<html lang="de">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Tree Heart</title>
    <style>
      :root {
        /* HELLERES THEME */
        --bg1: #f7fbff;
        --bg2: #eef6ff;
        --ink: #0f172a;
        --muted: rgba(15, 23, 42, 0.65);
        --shadow: 0 20px 60px rgba(2, 6, 23, 0.18);
        --radius: 18px;
      }
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      body {
        height: 100vh;
        color: var(--ink);
        font-family:
          ui-sans-serif,
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Helvetica,
          Arial;
        overflow: hidden;
        display: grid;
        place-items: center;
        background: linear-gradient(180deg, var(--bg1), var(--bg2));
        background: url("./DiaDosNamoradosbabe.jpg") center / cover no-repeat
          fixed;
      }

      /* Helleres, subtileres Grid + leichte Color-Glows */
      body::before {
        content: "";
        position: fixed;
        inset: 0;
        background:
          radial-gradient(
            900px 600px at 18% 18%,
            rgba(34, 197, 94, 0.1),
            transparent 60%
          ),
          radial-gradient(
            900px 600px at 82% 26%,
            rgba(236, 72, 153, 0.08),
            transparent 60%
          ),
          radial-gradient(
            1100px 700px at 50% 90%,
            rgba(59, 130, 246, 0.08),
            transparent 60%
          ),
          repeating-linear-gradient(
            to bottom,
            rgba(2, 6, 23, 0.05) 0 1px,
            transparent 1px 44px
          ),
          repeating-linear-gradient(
            to right,
            rgba(2, 6, 23, 0.04) 0 1px,
            transparent 1px 56px
          );
        opacity: 0.9;
        pointer-events: none;
      }

      .stage {
        width: min(1100px, 94vw);
        height: min(640px, 88vh);
        border-radius: var(--radius);
        border: 1px solid rgba(2, 6, 23, 0.08);
        box-shadow: var(--shadow);
        overflow: hidden;
        position: relative;

        /* heller, “milchiger” card look */
        background:
          radial-gradient(
            1200px 700px at 50% 0%,
            rgba(255, 255, 255, 0.95),
            rgba(255, 255, 255, 0.7)
          ),
          linear-gradient(
            180deg,
            rgba(255, 255, 255, 0.85),
            rgba(255, 255, 255, 0.65)
          );
      }

      canvas {
        width: 100%;
        height: 100%;
        display: block;
      }

      .hint {
        position: absolute;
        left: 50%;
        top: 14px;
        transform: translateX(-50%);
        padding: 8px 12px;
        border-radius: 999px;
        font-size: 12px;
        color: rgba(15, 23, 42, 0.85);
        background: rgba(255, 255, 255, 0.65);
        border: 1px solid rgba(2, 6, 23, 0.1);
        user-select: none;
        pointer-events: none;
        backdrop-filter: blur(10px);
      }

      /* Text left of tree */
      .typewrap {
        position: absolute;
        left: 6%;
        top: 54%;
        transform: translateY(-50%);
        width: min(380px, 40%);
        padding: 14px 14px;
        border-radius: 16px;

        /* heller + weniger “dark glass” */
        background: rgba(255, 255, 255, 0.62);
        border: 1px solid rgba(2, 6, 23, 0.1);
        backdrop-filter: blur(12px);
        box-shadow: 0 18px 50px rgba(2, 6, 23, 0.12);
        display: none;
      }
      .typewrap .title {
        font-size: 12px;
        letter-spacing: 0.9px;
        text-transform: uppercase;
        color: rgba(15, 23, 42, 0.65);
        margin-bottom: 10px;
      }
      .typewrap .text {
        font-size: 18px;
        line-height: 1.45;
        letter-spacing: 0.2px;
        color: rgba(15, 23, 42, 0.92);
      }
      .cursor {
        display: inline-block;
        width: 10px;
        height: 1.1em;
        transform: translateY(3px);
        margin-left: 6px;
        background: rgba(15, 23, 42, 0.65);
        animation: blink 0.9s infinite;
      }
      @keyframes blink {
        50% {
          opacity: 0;
        }
      }

      /* Optional image (only via code) */
      .sideImage {
        position: absolute;
        left: 6%;
        top: 18%;
        width: min(340px, 38%);
        aspect-ratio: 4 / 3;
        border-radius: 16px;
        border: 1px solid rgba(2, 6, 23, 0.1);
        box-shadow: 0 18px 50px rgba(2, 6, 23, 0.12);
        object-fit: cover;
        display: none;
        opacity: 0;
        transition: opacity 0.6s ease;
      }
      .sideImage.show {
        display: block;
        opacity: 1;
      }

      @media (max-width: 820px) {
        .typewrap {
          left: 50%;
          top: auto;
          bottom: 18px;
          transform: translateX(-50%);
          width: min(520px, 92%);
        }
        .sideImage {
          left: 50%;
          transform: translateX(-50%);
          top: 18px;
          width: min(520px, 92%);
        }
      }
    </style>
  </head>

  <body>
    <div class="stage" id="stage">
      <div class="hint">Klick auf den blinkenden Kreis</div>

      <img id="sideImage" class="sideImage" alt="Custom" />

      <div class="typewrap" id="typewrap">
        <div class="title">Message</div>
        <div class="text">
          <span id="typed"></span><span class="cursor" id="cursor"></span>
        </div>
      </div>

      <canvas id="c"></canvas>
    </div>

    <script>
      (() => {
        // =========================
        // CONFIG
        // =========================
        const TYPE_TEXT = "Happy Dia Dos Namorados Meu Amor!❣️";

        // Optionales Bild nur im Code:
        const IMAGE_URL = ""; // z.B. "images/meinbild.jpg"
        const IMAGE_TIMING = "afterText"; // "afterText" | "withText"

        // =========================
        // DOM
        // =========================
        const canvas = document.getElementById("c");
        const ctx = canvas.getContext("2d");
        const stage = document.getElementById("stage");

        const typewrap = document.getElementById("typewrap");
        const typedEl = document.getElementById("typed");
        const cursorEl = document.getElementById("cursor");

        const sideImg = document.getElementById("sideImage");
        if (IMAGE_URL) sideImg.src = IMAGE_URL;

        // =========================
        // HiDPI Resize
        // =========================
        function resize() {
          const dpr = Math.max(1, window.devicePixelRatio || 1);
          const rect = canvas.getBoundingClientRect();
          canvas.width = Math.floor(rect.width * dpr);
          canvas.height = Math.floor(rect.height * dpr);
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }
        window.addEventListener("resize", resize);
        resize();

        // =========================
        // Helpers
        // =========================
        const rand = (a, b) => Math.random() * (b - a) + a;
        const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
        const lerp = (a, b, t) => a + (b - a) * t;
        const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);
        const easeInOut = (t) =>
          t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

        // Heart mask: (x^2+y^2-1)^3 - x^2 y^3 <= 0
        function insideHeart(x, y) {
          const a = x * x + y * y - 1;
          return a * a * a - x * x * y * y * y <= 0;
        }

        // =========================
        // Scene State
        // =========================
        let phase = "idle";
        let tPhase = 0;
        let raf = null;
        let last = 0;

        const orb = { x: 0, y: 0, r: 18, vy: 0, blink: 0 };
        const ground = { y: 0, meadowProgress: 0 };

        let segments = [];
        let segProgress = 0;

        let leaves = [];
        let leafProgress = 0;

        // Typewriter
        let typing = false;
        let typeIndex = 0;
        let typeTimer = 0;

        // =========================
        // Build Tree
        // =========================
        function buildTreeSegments(baseX, baseY) {
          const segs = [];

          function branch(x, y, angle, len, depth, w) {
            const steps = Math.max(12, Math.floor(len / 6));
            let px = x,
              py = y;
            let a = angle;

            for (let i = 1; i <= steps; i++) {
              a += rand(-0.015, 0.015);
              const t = i / steps;
              const nx = x + Math.cos(a) * len * t;
              const ny = y - Math.sin(a) * len * t;

              segs.push({
                x1: px,
                y1: py,
                x2: nx,
                y2: ny,
                w: lerp(w, w * 0.6, t),
                col: `rgba(16,185,129,${lerp(0.95, 0.75, t)})`,
              });

              px = nx;
              py = ny;
            }

            if (depth <= 0) return;
            const endX = px,
              endY = py;
            const nextLen = len * rand(0.62, 0.74);
            const nextW = w * 0.72;

            branch(
              endX,
              endY,
              angle + rand(0.5, 0.75),
              nextLen,
              depth - 1,
              nextW,
            );
            branch(
              endX,
              endY,
              angle - rand(0.5, 0.75),
              nextLen,
              depth - 1,
              nextW,
            );
            if (Math.random() < 0.55) {
              branch(
                endX,
                endY,
                angle + rand(-0.25, 0.25),
                nextLen * 0.75,
                depth - 1,
                nextW * 0.9,
              );
            }
          }

          branch(baseX, baseY, Math.PI / 2, 155, 4, 11);
          return segs;
        }

        function makeHeartLeaves(cx, cy, scale, count) {
          const palette = [
            "#ff4d6d",
            "#ff8fab",
            "#f72585",
            "#ffb703",
            "#fb5607",
            "#8338ec",
            "#ff006e",
            "#ffd166",
            "#ff5c8a",
          ];
          const out = [];
          let tries = 0;

          while (out.length < count && tries < count * 90) {
            tries++;
            const x = rand(-1.25, 1.25);
            const y = rand(-1.35, 1.1);
            if (!insideHeart(x, y)) continue;

            out.push({
              x: cx + x * scale,
              y: cy + y * scale,
              s: rand(3.6, 6.8),
              rot: rand(0, Math.PI * 2),
              col: palette[(Math.random() * palette.length) | 0],
              a: 0,
              wob: rand(0, Math.PI * 2),
              pop: rand(0.85, 1.25),
            });
          }
          return out;
        }

        function drawHeart(x, y, size, rot, color, alpha) {
          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(rot);
          ctx.globalAlpha = alpha;
          ctx.fillStyle = color;

          const s = size;
          ctx.beginPath();
          ctx.moveTo(0, -0.25 * s);
          ctx.bezierCurveTo(
            0.55 * s,
            -0.95 * s,
            1.25 * s,
            -0.1 * s,
            0,
            0.95 * s,
          );
          ctx.bezierCurveTo(
            -1.25 * s,
            -0.1 * s,
            -0.55 * s,
            -0.95 * s,
            0,
            -0.25 * s,
          );
          ctx.closePath();
          ctx.fill();

          ctx.restore();
        }

        // =========================
        // Reset Scene
        // =========================
        function reset() {
          cancelAnimationFrame(raf);
          raf = null;
          last = 0;

          resize();

          const W = canvas.getBoundingClientRect().width;
          const H = canvas.getBoundingClientRect().height;

          ground.y = H * 0.86;
          ground.meadowProgress = 0;

          orb.x = W * 0.5;
          orb.y = H * 0.4;
          orb.vy = 0;
          orb.blink = 0;

          const baseX = W * 0.62;
          const baseY = ground.y;

          segments = buildTreeSegments(baseX, baseY);
          segProgress = 0;

          // ✅ LAUB HÖHER: vorher baseY - 182, jetzt deutlich höher
          const heartCx = baseX - 6;
          const heartCy = baseY - 325; // <- höher
          const heartScale = Math.min(W, H) * 0.215;

          leaves = makeHeartLeaves(heartCx, heartCy, heartScale, 720);
          leafProgress = 0;

          phase = "idle";
          tPhase = 0;

          // typewriter reset
          typing = false;
          typeIndex = 0;
          typeTimer = 0;
          typedEl.textContent = "";
          typewrap.style.display = "none";

          // image reset
          sideImg.classList.remove("show");
          sideImg.style.display = "none";
          if (IMAGE_URL) {
            sideImg.src = IMAGE_URL;
          }

          raf = requestAnimationFrame(loop);
        }

        // =========================
        // Click on orb to start
        // =========================
        stage.addEventListener("click", (e) => {
          if (phase !== "idle") return;

          const rect = canvas.getBoundingClientRect();
          const mx = e.clientX - rect.left;
          const my = e.clientY - rect.top;
          const dx = mx - orb.x;
          const dy = my - orb.y;

          if (dx * dx + dy * dy <= orb.r * 1.6 * (orb.r * 1.6)) {
            phase = "fall";
            tPhase = 0;
            orb.vy = 0;
          }
        });

        // =========================
        // Typewriter control
        // =========================
        function startTypewriter() {
          typing = true;
          typewrap.style.display = "block";

          if (IMAGE_URL && IMAGE_TIMING === "withText") {
            sideImg.style.display = "block";
            requestAnimationFrame(() => sideImg.classList.add("show"));
          }
        }

        // =========================
        // Main Loop
        // =========================
        function loop(ts) {
          const dt = Math.min(0.033, (ts - last) / 1000 || 0);
          last = ts;

          update(dt);
          draw();

          raf = requestAnimationFrame(loop);
        }

        function update(dt) {
          tPhase += dt;

          const H = canvas.getBoundingClientRect().height;
          ground.y = H * 0.86;

          if (phase === "idle") {
            orb.blink += dt;
            return;
          }

          if (phase === "fall") {
            orb.vy += 1500 * dt;
            orb.y += orb.vy * dt;

            if (orb.y + orb.r >= ground.y) {
              orb.y = ground.y - orb.r;
              orb.vy = 0;
              phase = "meadow";
              tPhase = 0;
            }
            return;
          }

          if (phase === "meadow") {
            const t = clamp(tPhase / 0.9, 0, 1);
            ground.meadowProgress = easeOutCubic(t);
            if (t >= 1) {
              phase = "tree";
              tPhase = 0;
            }
            return;
          }

          if (phase === "tree") {
            const t = clamp(tPhase / 2.8, 0, 1);
            segProgress = easeInOut(t);
            if (t >= 1) {
              phase = "leaves";
              tPhase = 0;
            }
            return;
          }

          if (phase === "leaves") {
            const t = clamp(tPhase / 2.4, 0, 1);
            leafProgress = easeInOut(t);

            if (t >= 1) {
              phase = "type";
              tPhase = 0;
              startTypewriter();
            }
            return;
          }

          if (phase === "type") {
            // Leaves laufen weiter
            for (const p of leaves) {
              p.wob += dt * 1.8;
            }

            if (typing) {
              typeTimer += dt;
              const charInterval = 0.035;
              while (
                typeTimer >= charInterval &&
                typeIndex < TYPE_TEXT.length
              ) {
                typeTimer -= charInterval;
                typedEl.textContent += TYPE_TEXT[typeIndex];
                typeIndex++;
              }

              if (typeIndex >= TYPE_TEXT.length) {
                typing = false;

                if (IMAGE_URL && IMAGE_TIMING === "afterText") {
                  setTimeout(() => {
                    sideImg.style.display = "block";
                    requestAnimationFrame(() => sideImg.classList.add("show"));
                  }, 250);
                }

                phase = "done";
                tPhase = 0;
              }
            }
            return;
          }

          if (phase === "done") {
            for (const p of leaves) {
              p.wob += dt * 1.8;
            }
            return;
          }
        }

        // =========================
        // Draw
        // =========================
        function draw() {
          const W = canvas.getBoundingClientRect().width;
          const H = canvas.getBoundingClientRect().height;

          ctx.clearRect(0, 0, W, H);

          // softer vignette but LIGHT
          ctx.save();
          const grd = ctx.createRadialGradient(
            W * 0.5,
            H * 0.4,
            40,
            W * 0.5,
            H * 0.6,
            Math.max(W, H),
          );
          grd.addColorStop(0, "rgba(255,255,255,0.10)");
          grd.addColorStop(1, "rgba(2,6,23,0.08)");
          ctx.fillStyle = grd;
          ctx.fillRect(0, 0, W, H);
          ctx.restore();

          // ground line (lighter)
          ctx.save();
          ctx.globalAlpha = 0.18;
          ctx.fillStyle = "rgba(2,6,23,0.35)";
          ctx.fillRect(18, ground.y, W - 36, 3);
          ctx.restore();

          if (ground.meadowProgress > 0) drawMeadow(W, H);
          if (segProgress > 0) drawTree();
          if (leafProgress > 0) drawLeaves();

          drawOrb();
        }

        function drawOrb() {
          if (phase === "idle") {
            const pulse = 0.5 + 0.5 * Math.sin(orb.blink * 5.8);
            const alpha = 0.25 + 0.75 * pulse;

            ctx.save();
            ctx.globalAlpha = alpha * 0.45;
            ctx.fillStyle = "rgba(255,85,140,1)";
            ctx.beginPath();
            ctx.arc(orb.x, orb.y, orb.r * 2.6, 0, Math.PI * 2);
            ctx.fill();

            ctx.globalAlpha = alpha;
            ctx.fillStyle = "rgba(255,255,255,0.95)";
            ctx.beginPath();
            ctx.arc(orb.x, orb.y, orb.r, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          } else {
            ctx.save();
            ctx.globalAlpha = 0.95;
            ctx.fillStyle = "rgba(255,255,255,0.95)";
            ctx.beginPath();
            ctx.arc(orb.x, orb.y, orb.r, 0, Math.PI * 2);
            ctx.fill();

            ctx.globalAlpha = 0.12;
            ctx.fillStyle = "rgba(2,6,23,1)";
            ctx.beginPath();
            ctx.ellipse(orb.x, ground.y + 8, orb.r * 1.4, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }
        }

        function drawMeadow(W, H) {
          const p = ground.meadowProgress;
          const meadowH = lerp(0, H * 0.22, p);
          const yTop = ground.y - meadowH;

          // base wash (heller)
          ctx.save();
          ctx.fillStyle = "rgba(34,197,94,0.10)";
          ctx.fillRect(0, yTop, W, meadowH + (H - ground.y));
          ctx.restore();

          // grass gradient (heller)
          ctx.save();
          ctx.globalAlpha = 0.7;
          const g = ctx.createLinearGradient(0, yTop, 0, ground.y + 70);
          g.addColorStop(0, "rgba(34,197,94,0.0)");
          g.addColorStop(0.35, "rgba(34,197,94,0.28)");
          g.addColorStop(1, "rgba(34,197,94,0.12)");
          ctx.fillStyle = g;
          ctx.fillRect(0, yTop, W, meadowH + 90);
          ctx.restore();

          // flowers
          const flowerCount = Math.floor(140 * p);
          ctx.save();
          for (let i = 0; i < flowerCount; i++) {
            const fx = (i * 19) % W;
            const fy = ground.y - rand(6, meadowH * 0.85);
            const r = rand(1.3, 2.3);
            ctx.globalAlpha = 0.25 + 0.3 * Math.random();
            ctx.fillStyle =
              Math.random() < 0.5
                ? "rgba(255,0,110,0.85)"
                : "rgba(255,209,102,0.90)";
            ctx.beginPath();
            ctx.arc(fx, fy, r, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();
        }

        function drawTree() {
          const upto = Math.floor(segProgress * segments.length);

          ctx.save();
          ctx.lineCap = "round";
          ctx.lineJoin = "round";

          for (let i = 0; i < upto; i++) {
            const s = segments[i];
            ctx.strokeStyle = s.col;
            ctx.lineWidth = s.w;
            ctx.beginPath();
            ctx.moveTo(s.x1, s.y1);
            ctx.lineTo(s.x2, s.y2);
            ctx.stroke();
          }
          ctx.restore();
        }

        function drawLeaves() {
          const count = Math.floor(leafProgress * leaves.length);

          // sparkle region etwas höher (passt zum höheren Herz)
          if (leafProgress > 0.2) {
            ctx.save();
            ctx.globalAlpha = 0.1 * leafProgress;
            for (let i = 0; i < 18; i++) {
              ctx.beginPath();
              ctx.arc(
                lerp(
                  canvas.getBoundingClientRect().width * 0.46,
                  canvas.getBoundingClientRect().width * 0.76,
                  Math.random(),
                ),
                lerp(ground.y - 320, ground.y - 140, Math.random()),
                rand(1, 2.2),
                0,
                Math.PI * 2,
              );
              ctx.fillStyle = "rgba(255,255,255,0.9)";
              ctx.fill();
            }
            ctx.restore();
          }

          for (let i = 0; i < count; i++) {
            const p = leaves[i];
            p.a = Math.min(1, p.a + 0.06);

            const sway =
              phase === "type" || phase === "done" ? Math.sin(p.wob) * 0.6 : 0;
            const pop = 1 + Math.sin(p.wob) * 0.05;

            drawHeart(
              p.x + sway,
              p.y,
              p.s * pop * p.pop,
              p.rot + sway * 0.003,
              p.col,
              p.a,
            );

            p.wob += 0.012;
          }
        }

        // Init
        reset();
      })();
    </script>
  </body>
</html>
